#pragma once

inline const char* QuicToString(QUIC_STATUS Status)
{
    switch (Status) {
    case QUIC_STATUS_SUCCESS:                   return "SUCCESS";
    case QUIC_STATUS_PENDING:                   return "PENDING";
    case QUIC_STATUS_OUT_OF_MEMORY:             return "OUT_OF_MEMORY";
    case QUIC_STATUS_INVALID_PARAMETER:         return "INVALID_PARAMETER";
    case QUIC_STATUS_INVALID_STATE:             return "INVALID_STATE";
    case QUIC_STATUS_NOT_SUPPORTED:             return "NOT_SUPPORTED";
    case QUIC_STATUS_NOT_FOUND:                 return "NOT_FOUND";
    case QUIC_STATUS_BUFFER_TOO_SMALL:          return "BUFFER_TOO_SMALL";
    case QUIC_STATUS_HANDSHAKE_FAILURE:         return "HANDSHAKE_FAILURE";
    case QUIC_STATUS_ABORTED:                   return "ABORTED";
    case QUIC_STATUS_ADDRESS_IN_USE:            return "ADDRESS_IN_USE";
    case QUIC_STATUS_CONNECTION_TIMEOUT:        return "CONNECTION_TIMEOUT";
    case QUIC_STATUS_CONNECTION_IDLE:           return "CONNECTION_IDLE";
    case QUIC_STATUS_UNREACHABLE:               return "UNREACHABLE";
    case QUIC_STATUS_INTERNAL_ERROR:            return "INTERNAL_ERROR";
    case QUIC_STATUS_CONNECTION_REFUSED:        return "CONNECTION_REFUSED";
    case QUIC_STATUS_PROTOCOL_ERROR:            return "PROTOCOL_ERROR";
    case QUIC_STATUS_VER_NEG_ERROR:             return "VER_NEG_ERROR";
    case QUIC_STATUS_USER_CANCELED:             return "USER_CANCELED";
    case QUIC_STATUS_ALPN_NEG_FAILURE:          return "ALPN_NEG_FAILURE";
    case QUIC_STATUS_STREAM_LIMIT_REACHED:      return "STREAM_LIMIT_REACHED";
    }

    return "UNKNOWN";
}

inline const char* QuicToString(QUIC_LISTENER_EVENT_TYPE Type)
{
    switch (Type)
    {
    case QUIC_LISTENER_EVENT_NEW_CONNECTION:      return "QUIC_LISTENER_EVENT_NEW_CONNECTION";
    case QUIC_LISTENER_EVENT_STOP_COMPLETE:       return "QUIC_LISTENER_EVENT_STOP_COMPLETE";
    }
    return "UNKNOWN";
};

inline const char* QuicToString(QUIC_CONNECTION_EVENT_TYPE Type)
{
    switch (Type)
    {
    case QUIC_CONNECTION_EVENT_CONNECTED:                         return "QUIC_CONNECTION_EVENT_CONNECTED";
    case QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT:   return "QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT";
    case QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER:        return "QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER";
    case QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE:                 return "QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE";
    case QUIC_CONNECTION_EVENT_LOCAL_ADDRESS_CHANGED:             return "QUIC_CONNECTION_EVENT_LOCAL_ADDRESS_CHANGED";
    case QUIC_CONNECTION_EVENT_PEER_ADDRESS_CHANGED:              return "QUIC_CONNECTION_EVENT_PEER_ADDRESS_CHANGED";
    case QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED:               return "QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED";
    case QUIC_CONNECTION_EVENT_STREAMS_AVAILABLE:                 return "QUIC_CONNECTION_EVENT_STREAMS_AVAILABLE";
    case QUIC_CONNECTION_EVENT_PEER_NEEDS_STREAMS:                return "QUIC_CONNECTION_EVENT_PEER_NEEDS_STREAMS";
    case QUIC_CONNECTION_EVENT_IDEAL_PROCESSOR_CHANGED:           return "QUIC_CONNECTION_EVENT_IDEAL_PROCESSOR_CHANGED";
    case QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED:            return "QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED";
    case QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED:                 return "QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED";
    case QUIC_CONNECTION_EVENT_DATAGRAM_SEND_STATE_CHANGED:       return "QUIC_CONNECTION_EVENT_DATAGRAM_SEND_STATE_CHANGED";
    case QUIC_CONNECTION_EVENT_RESUMED:                           return "QUIC_CONNECTION_EVENT_RESUMED";
    case QUIC_CONNECTION_EVENT_RESUMPTION_TICKET_RECEIVED:        return "QUIC_CONNECTION_EVENT_RESUMPTION_TICKET_RECEIVED";
    case QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED:         return "QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED";
    }
    return "UNKNOWN";
}


inline const char* QuicToString(QUIC_STREAM_EVENT_TYPE Type)
{
    switch (Type)
    {
    case QUIC_STREAM_EVENT_START_COMPLETE:            return "QUIC_STREAM_EVENT_START_COMPLETE";
    case QUIC_STREAM_EVENT_RECEIVE:                   return "QUIC_STREAM_EVENT_RECEIVE";
    case QUIC_STREAM_EVENT_SEND_COMPLETE:             return "QUIC_STREAM_EVENT_SEND_COMPLETE";
    case QUIC_STREAM_EVENT_PEER_SEND_SHUTDOWN:        return "QUIC_STREAM_EVENT_PEER_SEND_SHUTDOWN";
    case QUIC_STREAM_EVENT_PEER_SEND_ABORTED:         return "QUIC_STREAM_EVENT_PEER_SEND_ABORTED";
    case QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED:      return "QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED";
    case QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE:    return "QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE";
    case QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE:         return "QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE";
    case QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE:    return "QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE";
    case QUIC_STREAM_EVENT_PEER_ACCEPTED:             return "QUIC_STREAM_EVENT_PEER_ACCEPTED";
    }
    return "UNKNOWN";
}

#ifdef WIN32
#define QUIC_ERRCODE_(expr) "0x" << std::hex << (int)(Status)
#else
#define QUIC_ERRCODE_(expr) (int)(Status)
#endif

#define CHECK_QUIC(expr) [&]{ \
    const QUIC_STATUS Status = (expr);\
    /*LOG(INFO) << &(#expr[13]) << ": " << QuicToString(Status);*/ \
    CHECK(QUIC_SUCCEEDED(Status)) << #expr << " failed: " << QuicToString(Status) << " (" << QUIC_ERRCODE_(Status) << ")" ; \
    return Status; }()
